# .gitlab-ci.yml
# å¤šæœåŠ¡é¡¹ç›®CI/CDæµæ°´çº¿é…ç½®â€”â€”æ”¯æŒåˆ†æ”¯æµ‹è¯•å’Œæ ‡ç­¾ç”Ÿäº§éƒ¨ç½²
#
# æµæ°´çº¿è§¦å‘è§„åˆ™ï¼š
# 1. åˆ†æ”¯æ¨é€è§¦å‘å™¨ï¼šç”¨äºå¼€å‘å’Œæµ‹è¯•ï¼ˆä¾‹å¦‚ ci-deploy-config åˆ†æ”¯ï¼‰
# 2. æ ‡ç­¾æ¨é€è§¦å‘å™¨ï¼šç”¨äºç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
#
# æµæ°´çº¿é˜¶æ®µæè¿°ï¼š
# 1. prepare     : è§£æè§¦å‘ä¿¡æ¯ï¼Œç¡®å®šéƒ¨ç½²ç¯å¢ƒå’Œç›®æ ‡æœåŠ¡
# 2. build       : å¹¶è¡Œæ„å»ºæ¯ä¸ªæœåŠ¡çš„Dockeré•œåƒï¼Œå¹¶æ¨é€åˆ°é•œåƒä»“åº“
# 3. update-config: æ›´æ–° GitOps é…ç½®ä»“åº“å¹¶è§¦å‘ ArgoCD åŒæ­¥

# å…¨å±€å˜é‡å®šä¹‰
variables:
  # é¡¹ç›®åŸºæœ¬ä¿¡æ¯
  PROJECT_NAME: "inkspace"
  ECR_REGISTRY: "192.168.4.104:5000"
  KUBE_NAMESPACE: "inkspace"
  RNAMESPACE: "iceymoss"
  REGISTRY_USERNAME: "iceymoss"
  REGISTRY_PASSWORD: "Qq/2013XiaoKUang"
  GITOPS_CONFIG_REPO: "127.0.0.1/k8s/ic2-deploy-config.git"
  # æœåŠ¡åˆ—è¡¨å®šä¹‰
  ALL_SERVICES: "blog-api admin-api task blog-frontend  admin-frontend"

  # default image tag policy
  IMAGE_TAG_PREFIX: "${CI_COMMIT_REF_NAME//\//-}"

# stage definition
stages:
  - prepare

# å·¥ä½œæµè§„åˆ™ï¼šæ”¯æŒåˆ†æ”¯æµ‹è¯•å’Œæ ‡ç­¾ç”Ÿäº§é˜¶æ®µéƒ¨ç½²
workflow:
  rules:
    # æ ‡ç­¾è§¦å‘å™¨â€”â€”Proç”¨äºç”Ÿäº§ç¯å¢ƒï¼ŒDevç”¨äºæµ‹è¯•ç¯å¢ƒ
    - if: '$CI_COMMIT_TAG =~ /^(pro|dev)-([a-z-]+)-v[0-9]{14}$/'

# =============================================
# Phase 1: å‡†å¤‡é˜¶æ®µâ€”â€”ä»…é€šè¿‡æ ‡ç­¾æ§åˆ¶éƒ¨ç½²
# Purpose: åªå…è®¸ç‰¹å®šæ ¼å¼çš„æ ‡ç­¾è§¦å‘æµæ°´çº¿ï¼Œå¹¶å®Œå…¨ç¦ç”¨åˆ†æ”¯è§¦å‘ã€‚
# Rule: æ ‡ç­¾æ ¼å¼å¿…é¡»ä¸º (pro|dev)-<service>-vYYYYMMDDHHMMSS
# =============================================

# å®šä¹‰å¯é‡å¤ä½¿ç”¨çš„ä½œä¸šæ¨¡æ¿é”šå®šä¹‰
.parse_template: &parse_template
  stage: prepare  # å°†å·¥ä½œé˜¶æ®µå®šä¹‰ä¸ºå‡†å¤‡é˜¶æ®µï¼ˆå‡†å¤‡é˜¶æ®µï¼‰
  image: alpine:latest  # ä½¿ç”¨è½»é‡çº§ Alpine Linux é•œåƒ
  tags:
    - docker  # æŒ‡å®šåœ¨è¿è¡Œå™¨ä¸Šè¿è¡Œï¼Œå¸¦æœ‰ Docker æ ‡ç­¾
  before_script:
    - apk add --no-cache git  # å®‰è£…gitå·¥å…·ï¼ˆAlpineä½¿ç”¨apkåŒ…ç®¡ç†å™¨ï¼‰
  artifacts:
    reports:
      dotenv: build.env  # å…³é”®ï¼šå°†build.envæ–‡ä»¶ä¸­çš„å˜é‡ä¼ é€’ç»™åç»­ä½œä¸š
  interruptible: true  # å…è®¸åœ¨æ–°æµæ°´çº¿å¯åŠ¨æ—¶ä¸­æ–­å½“å‰ä½œä¸š

# æ ‡ç­¾è§£æå·¥ä½œâ€”â€”æ ¸å¿ƒé€»è¾‘ï¼šä»…å¤„ç†æ ‡ç­¾è§¦å‘å™¨ï¼Œæ‹’ç»åˆ†æ”¯è§¦å‘å™¨
parse_trigger:
  <<: *parse_template  # ç»§æ‰¿ä¸Šè¿°å®šä¹‰çš„æ¨¡æ¿é…ç½®
  # æ·»åŠ ä¸€æ¡è§„åˆ™ï¼šåªæœ‰ç¬¦åˆç‰¹å®šæ ¼å¼çš„æ ‡ç­¾æ‰å…è®¸è§¦å‘æ­¤ä»»åŠ¡
  rules:
    - if: '$CI_COMMIT_TAG =~ /^(pro|dev)-([a-z-]+)-v[0-9]{14}$/'  # åªè¿è¡Œä¸æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…çš„æ ‡ç­¾ã€‚
      when: always  # åŒ¹é…æ—¶æ€»æ˜¯è¿è¡Œ
  script:
    - |
      echo "ğŸš€ Tag trigger mode - production/staging/development environment deployment"
      echo "ğŸ“ current tag: $CI_COMMIT_TAG"

      # Tag format regular expression: environment-service name-version timestamp
      TAG_PATTERN="^(pro|dev)-([a-z-]+)-v([0-9]{14})$"

      # Use grep to verify the Tag format (a more compatible way)
      if echo "$CI_COMMIT_TAG" | grep -qE "$TAG_PATTERN"; then
        # extract various parts of the tag
        DEPLOY_ENV=$(echo "$CI_COMMIT_TAG" | sed -E "s/$TAG_PATTERN/\\1/")  # Extraction environment (pro/dev/stag)
        TARGET_SERVICE=$(echo "$CI_COMMIT_TAG" | sed -E "s/$TAG_PATTERN/\\2/")  # extract service name
        VERSION_TIMESTAMP=$(echo "$CI_COMMIT_TAG" | sed -E "s/$TAG_PATTERN/\\3/")  # extraction time

        # set environment variables
        export TRIGGER_TYPE="tag"  # the trigger type is fixed to tag
        export DEPLOY_ENV="$DEPLOY_ENV"  # Deployment environment (pro-production, dev-development, stag-staging)
        export TARGET_SERVICE="$TARGET_SERVICE"  # target service name
        export VERSION_TIMESTAMP="$VERSION_TIMESTAMP"  # version timestamp 14 digits

        # format time displayï¼šYYYY-MM-DD HH:MM:SS
        VERSION_DATE="${VERSION_TIMESTAMP:0:8}"  # Extract date part (YYYYMMDD)
        VERSION_TIME="${VERSION_TIMESTAMP:8:6}"  # Extract time part (HHMMSS)
        export VERSION_READABLE="${VERSION_DATE:0:4}-${VERSION_DATE:4:2}-${VERSION_DATE:6:2} ${VERSION_TIME:0:2}:${VERSION_TIME:2:2}:${VERSION_TIME:4:2}"

        echo "âœ… tag parsed successfully"
        echo "   environment: $DEPLOY_ENV"
        echo "   target service: $TARGET_SERVICE"
        echo "   time: $VERSION_TIMESTAMP"
        echo "   readable time: $VERSION_READABLE"

      else
        # If the Tag format does not match, output an error message and exit (theoretically it will not be executed here because the rules have been filtered)
        echo "âŒ tag format is incorrect"
        echo "ğŸ“‹ expected-format: (pro|dev|stag)-<service>-vYYYYMMDDHHMMSS"
        echo "ğŸ’¡ example:"
        echo "   - production environment: pro-em-v20241201143025"
        echo "   - development environment: dev-em-v20241201143025"
        echo "   - staging environment: stag-em-v20241201143025"
        echo "ğŸ”§ supported services: em, admin-api, exchange-rate, renderers, wc-server"
        exit 1  # Exit code 1 indicates failure and stops the pipeline.
      fi

      # determine the scope of services to be addressed
      if [ "$TARGET_SERVICE" = "all" ]; then
        # If the service name is all, all services are processed
        export SERVICES_TO_PROCESS="em admin-api exchange-rate renderers wc-server"
        echo "ğŸ¯ scope of processing all services"
      else
        # Otherwise, only the specified single service will be processed
        export SERVICES_TO_PROCESS="$TARGET_SERVICE"
        echo "ğŸ¯ processing scope single service - $TARGET_SERVICE"
      fi

      # set image label for docker image naming
      export IMAGE_TAG="${DEPLOY_ENV}-${TARGET_SERVICE}-${VERSION_TIMESTAMP}"
      echo "ğŸ³ mirror tag: $IMAGE_TAG"

      # Write environment variables to the build.env file (for use by subsequent jobs)
      {
        echo "TRIGGER_TYPE=$TRIGGER_TYPE"  # trigger type
        echo "DEPLOY_ENV=$DEPLOY_ENV"  # deployment environment
        echo "TARGET_SERVICE=$TARGET_SERVICE"  # target service
        echo "SERVICES_TO_PROCESS=$SERVICES_TO_PROCESS"  # list of services to process
        echo "IMAGE_TAG=$IMAGE_TAG"  # docker image tags
        echo "VERSION_TIMESTAMP=$VERSION_TIMESTAMP"  # version timestamp
        echo "VERSION_READABLE=$VERSION_READABLE"  # readable version time
      } > build.env

      echo "ğŸ“„ Environment variables have been written to the build.env file"
      echo "ğŸ” file content preview:"
      cat build.env